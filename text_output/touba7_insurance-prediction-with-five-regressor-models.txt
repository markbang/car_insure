# Insurance

![](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHCBUWFRgVFhUYGBgYGBgYGBgYGBgYGBgYGBgaGhgYGBgcIS4lHB4rHxgYJjgmKy8xNTU1GiQ7QDs0Py40NTEBDAwMEA8QHxISHzooJCs1NDQxPz06NjU1NTY2ODY2NTYxNTw0NDQ2NDE/NDc+NDQ0NzQxNjQ0NDQ0Nj00NDQ0Nf/AABEIAKgBLAMBIgACEQEDEQH/xAAcAAABBQEBAQAAAAAAAAAAAAAFAAECAwQGBwj/xABGEAACAQIDBAcEBwYEBAcAAAABAgADEQQSIQUxQVEGImFxgZGhEzJCsRRSYnKSosEHIzOCstEVFkNjc8Li8DRUg5Oj0uH/xAAaAQEAAgMBAAAAAAAAAAAAAAAAAwQBAgUG/8QAKhEBAAICAQMDAwQDAQAAAAAAAAECAxEhBBIxQVFhBRNxIjKBkSOx0RX/2gAMAwEAAhEDEQA/APRMZhVrUnpMSodGTMN6kjRh2g2PhA2w8czBqdUZa1M5HXtG5l5ow6wPI87w4jTDtDZqVHWpdkqKLB0IDZb3yODcOvYRpfSxgbkjkTMlNwLGp4hAD63EVTAo4s+ZwfrM1vIG0C0tHE5vZKNRxeIwwZmpKtKrTDsWKCoWVkzMblcyEjledGpgPGElIiBMGREQjwGJjKZHNHBgPeK8gTFeBMmImRLCxJNgBck7gBvJgPZe1K+JX2qIiU21QPmLunB2tol99td8A+DHEwfSXX36bD7SddfQZvNZTV25TXRQ9V+CIhLE8ixsqd7ECBT0mcGpg6Q941XqkfYSk6Fj2ZqqiFqQgnA4F2qtia9vaMoRVU3WkgNwiHjqSS3E9gABpFgTESxRgYExL6J1EzmWK0DNgxZFHIWPeND6y0Smt1GLfA5vf6jn3gewnUHmSOUuXWAoxlVXF010Lrf6oOZvwrc+kpw+0EdiiscygEqysjAHccrgGxsdeyBqMYSUiTAQiMkJFoCvHAkRJQGjxCKA8UUeBXGvHyxQHk0lYltPfA5oNfaWIt8OHwqnvLVm+RHnDywF0fQVHxGJ4V67lP8Ah07UkI7CELfzQ6NIE4yiMJYg39xI7wIAnH7RcuaNAKXX33cEoh+qFFs7+IAvxOkzHYzPrUxOIY80qezA7lQARbEHUB4sMx7SdSfEkmFAYHObQoYvBg1kqPisOuro4X26LxdGUAOAN4Iv2w1s/HLWprURsysAVPMGEaL2tAOzcCuHetSQWQVWdF4KtRVcqOwM72gFyZFnkbyp3gY+kuJyYTEsN4oVbd+RgJn2DUC0UA4KBKukiF8NWQb2pOB3lDaC9jYu9JDfeoPpA69MTLRWvOeTE9s5el0nxL5usqWYiwUHceZmtrRWNylw4bZbdtXpqPLUM8zTb+JH+p+Vf7TVQ6VYleKN95f7Wmn3qrX/AJ2b4/t6JeNOV2b0wVyFqpkv8Sm6+IOonTF5vW0W8KuXDfFOrRpZeTzTK1SIVhzmyJrLTI+zqJ+Be62n4d0sDywPAjSoqoAVQByAAHpM216dnw7gDNndCeORkLEeaLN4lO1N1JeOct+Fbf8ANAlGtHXdEogK8VpJRAe1MXUq1Gw9FiiJYVaq++WIB9mh+HQi7b9bC2+AWq1UT33VfvMB85NHUi4II5g3gvCbCw6D+EjE72dQ7MebM1yT3xVejVLV8PbDVd6vTFkJ5VKY6rqdxvryIgFYlmLZuLZ1ZXXJVRslRL3Aa18ynijAhgeR5zaIEpG8kJG0AOmxuP0nE35+2Y+huPSXpgKi6riXbsqJTdfyqrfmm5Y8DKHqr7yBxzpnXvyPu8GMHba22i4atkfLVKZEVwUcVKh9mhyMAdGa+7hDimBtu4BMRXoJUVWRM9VlOt2saaAjl1nbvQQN2Awi0qaU0FlRFRe5RYTTeDDskoP3Fd0+w59tT8nOcDsVwIwq4pPfopUHOk9ie3JUAt3ZjAJ3mjDbxAh2mQLtQrr2ZA/9DGVvt9xcUsPWd/hzoaaBuBdn+HnlBPZAbZS2QDlp5afpN4aYsBhyiKrG7AC55m2p8TNDPA0K8Hitmd2vcE6Hs4SVSppvnLYTa4oKKeIDIy9XOytkcDQOj2sQbXte4vYwOvL2lD1Jz3+bsJ/5in+ISp+k+HPuOz/cR3/pUwCmMxNgZwmysZkXJuyEoO5TYegEJY/adV75KLgcGqEIPLVvScRtpqyPcuBnuxCbgRZSLnuEDuBtRRqzAd5AgjDalyNxdiO4mcUAxOpJJ5m++drgksgHZIc3h0fpsf5Jn4aYoopWdxdhKBd1Qb2YKPEz09uqAOQA8pxfQ3Dhqpc/ApI+82gPledhiH0ljBXiZcT6nk3eK+0MGPxWUE3nL4npZTUlVdWcXsoO8jhM37Qccy4dwpIJKLcb7E6+gt4zzHZCXqp4/Iydzojc6en4TpNibZiy68Mug7BrCuE6YuPfRWHNSVPkbzk6K2AEtlT7lt+XoY6PDNdTD07ZW3qNawV7N9Ruq3hz8ITxWrr9lfVv/wAAnj4M6PYXSWojKjg1FYhQd7gnQWJ94dhklM3pKl1H06ax3Y538O+EcRrRCTuUspDWA9mDr1b7/bVP6zDtLfAODf8Af4hR8NU+qq36wDAEmkgstpwM2IpgV2bi1OmD25Wex8jLJnqMDXfXdlX8Ki48yZpEBxGyx7SQEDOJKMBJQGUQdSbNXqtyIQdyLu8yfOE03wJsNswZ9+Z3bzMAtHvGEUBjK3lhkGEChzM9VpqcTHXEDFiK1pmOMO68fFvaBMTiLQCNTFd3pBuK2xqVQXI3nco/ueyD8TirAnkDbtPCZqSZVA38zzPE+cjyXmscLvRdNGa078Q21MUXFmHiD+k5TpJRbLc7lYEHv0P6ToYSq7JthBiGYWZygQrfNa4ve/2W0twkVclt+6/n6LDqNcTPEevLzbZNAu6i27U/pOzRbCbNo7CbCsFZEUsucFNxB0PAajjKalBltmVlzDMuZStwdxF947ZjJbulv0WCMdd7iZn2RiiBikS8L9HceKVTX3XGU9mtwfP5zp8ZitJwIMuGKcCwY25HUeElx5O3iXO6zo5yz318/wC2Dpxic1NlvxU+RnLdH8MWfNwGn9/++2dPi8CtT3ySOV7CW0MOqCygAdkktljXCt0/QZO6JvxELVEeKKVnaKdF0R2QtZ2d1uiAgjUXZgQBca7rnynPotyANZ6lsPZ4o0VT4rZnPNjv8t3hJMVe634Uuvzfbx6jzPDEvR5k/gYrEU1G5HZa6f8AyAuB3NJLhsev+vh3HDNRdD4kVCPSG4pbefAa/wDiJFkbCofr5ajkdoUkD1luxdk+xUguzu7F3d/ed23sbaDuG4QwRI2gISaNaQMUAZjqGISoalEJURyC1N3KMrAWLI4Ugg2HVNtb68JF9o4kD/wZJ/41OFrxWgc++0sedEwlJBzqYgn8qIb+cgaG0zr9KoU/srhy4H8zPczobR7QI3jCSjQJIbEHtnPbPqphy1Kq6oVdsmY5c6XOVkv71xbduNxOgjEwB3+Jqfcp1XtyTIPxVCoI7ReI45xq9BwvFlZHt3qDfyBm8iNApp11YXUgg8RJMZixBCVARoHvccMw1v4g+k1oYDNMtcTU0z1VgA8emk53EUjedfiKN4PqYLsgcdjaZynSTvBHTbabCocPTNgls7Dez2vlvyXTxvyjbI2qrqAxAYbx+shzVmY3DpfTs1aWmtuNi5nbY/DabOwlt5V3HkW+bzhmqpxZfEiGaHS0nErXYpUdEyAKwUWOYX0vY9YyKnHl0Oo/VMdsxxv19dcOq6R0xjEqBLZ8NXyfyNlVvC9z/IZOoKT7SFJwpFKgFpq3ul9GtbicrbuzsnM9HNtijiGqVL5Kmb2lhfViWDW42b0Yy76IMXUq1UxCJVNViiuWS6j3GDbwbAbgbW4Tbe+fVV+1NN1tOoiOJ+ZLbu03KvSxGEppV0yuoKldd4PxAi9je3ZM/SfZlPDNSVc2c0w9S5uLnTTlqG9Id2yVIwdGvUSpXFZfaMhvZC1iGPbdd9r5SZk6RYSpW2jkKNZmpqDY2yAAs1+Qu8xaPP8ADfDeImPSNTM+0/gOr9Gqgq0qKsrPUp+0sbqEFiSGOvIi8zbS2DiKAzVKZCbs6kMuvMjUeNp2uGrK2NxVYsFTD0Vphj7q36zHwKt5wZVUYPCVadSuKr4hf3armK5WBGcX3DW57hMzWCvU5NxHmeONed/8cXFOz6HbNRQtWsoJrk06KsAeqFLMxB5hbD/qgbYWyVq4s0XByKamextolxv4a5Zp2TqPlajqazNo9Ijf599AsUM4jYbDGfRQbZn6jEX6hGYMedl9QZlOyqjVmoU1NRkZlJUadU2JJO4X5zE1lvGbHPr6b/hf0ZoB8TTB3Bi34QWHqBPTrzzE4PE4R1qNSZLHRjYrc6WJUka6wg3TGpuCLfvPykuKYrExZz+txXzWicfMa93fRp54nTDEg6imRyyt8806jYe30xAIIyOouy3uCPrKeI+UlretuIlz8nS5cde60cDTGNIhpKbq5GNJGNAcRR1EZ2CgsxsF3mAjGmVcUzarRcjmSik9ylr+dpL6VzVweWQn1W49YF9oxivEYDxo43EnQAXJOgAG8mDsDtijWuaTM6jTOEcIbfVYizDtEDdEZCnWVtzA9xkMVikpoXd1RF1LMQAIArb1UZ8Ol+szs4HHIiEMe67p5wkm6ANnh8TiGxTKUpqop0FYWbLmzNUIOq5jbTkq31nRBYDNK3EvKytkgZXWVonWHePnNZSQK21gfOuPYtUd295ndj3sxJv5zKy9k6vp9sVsNiGZR+6qkujb7FjdkPaDfwnKM/ZAYDsluHU51tzHzlQaEdlU8ziYmdQ3rEzMRHq7CgeqO6WyKDSSlJ6isaghDNHpTi1XKKxItYEqrMB2MRfzgaKImY8MXpS37oiRPDbYZKFahluazAtULHMNRcEW617Nx+KEKePw9ehh6NdyjUXsWysQ1I36oK3INgo15Tl2xCA2LqDyLC8sDCbbmEM48d5/TOp3vjz407in0ko1MVTX2AK03CUagYqVBst8trWPLlaSoUfY1to1iPcVgvfVGew/J5zhpauIcKyhmCtbMuY5Wta1xx3Dyme/3aT0cRxWeNRE/wBvQ9jVErLRxrWz0aVSnU3b1AsT4Zj/ADwMuKahs4VUOWpiarZnHvDrNuPDRfzGc9gtq1KVOrSUjLVXKwINxoRdTfQ2NuPCENlbZpewOFxKM1PNmVkIzISbnf2knxIsZtFolDbp7UmZ1uNxx8K9h1qtavRovUd19orFWYsOpdidewHznQ9INo1VqP7TBJUog9Vihvaw1Li4Gt+Ag7o7WwdLF51qsKYpnK1awJqM1iNAABl/WVbYoYhaTt9LWtRZgGAqFrlmuBlN7ajgeERuKl+22aONRqPO459dac1Nmy8SUqI44ML/AHToR5GY5dg6eZ0Ti7qoHjc+SgmR1/dC7nmIxTvxqXqlJry8TPRE0CXXlzmMIjHECxFmK5eq5J6lMhFA4uBd2PbqF/lPOb6O+CdigD2631GJrZuzM+YflZYBIGSkLSV4FUYRzFA5/wDaBXZNn4jLoXCU79lSoiN+ViPGX9HaASigAsAALd0p6dJfAV77lVH/AAVEe/5Zt2Mf3aW5QNlbDI/vKCefEdzDUTB/gOHzByhdgbqXd6mU81DsQp7RCgjGBBUAj2k7RrQIkSOWWWiIgUlZU4mkiVssADtvAJWptTqKGU7wefAg8D2zzbHdDKSEkO9uRK+V7T1nFJeANpYLNpA80Oy0Q6KO86/Oa9l4ZblgALaeMM4/ZjhWKi5sbd8y4SlkQLxG/v4yLNOq6dD6fii2Tc+i4RRRSq7p1E53bu1WzNSQ5VGjEb2PEX4Ds4zpKYnH7P2VWxldlpLe7sWc+6oJOpMmw1iZmXN+pZLVpFYnzvYNUtNWz9pPSIsSV4g6jw5T0On+ytct3xDZra5UFr+M5LpJ0UfCnRg691mHhLExvy41bTWdxOpdDh6odQw3EXlsGbABFJQeUJynaNTMPTYLTbHEz6wUe/kNT3DfGmLbFfJQqNxK5B/P1T6EzERuYhtlv2UmfaJatgdHsXjkNcVhSS5CLlzAgcxpfvMLP0Xxab0V/tIfmraj1nU/s/AGBoD7AnTGXJpWY1p53H1WWlu6J/t5EcLVzZPY1S17ZRTcnxNrDvJtOq6MdHHRzXrAB7ZUQG+RSdSxG9jYXtoLW7T2TRrTFcda8t8/WZM1e2eI+EUWTEaPebqhGOBGEksCatA20QcPVbEDWjUC+2t/puoyrVI+oVADH4SoO4kgsI+aBVRqqwBBBB3EHSM+Kpg2Lrf7wmX/AAfDg3FJBc3IUZQSeOUaTQmFUCwQW7hAsijAyuviUQXd1UDixAHrAp2lhhUpPTYXDo6EHkykfrBHQ3El8Mgb31BR+x0JVx+IGaX2/Rbq089Und7NGdfFwMg8TOe6PpilxGJpqiUw7isoqEsyh9GGVDYnMpPvfFA7hTJQWdmVXFqmJftFICkPMXf80q/yzhj7yu/a9Wq582aAZv2xFYCPQ3AtoaA03dZ9O7rSunss4GtS9lUqNh67PTak7lxTcU2qI9Nm1AIpuCt+IgHzEBGRryYECETJBHSbEVlFOnRYI9VyC5FyiKLsUB0LElQL7rk8IMTosSczYvFluf0h7fh3QOirJMbUL3g9ej9Zfcx+JHYxRx45k/WXLh8cnxUa45ENRe33hmUnwECT4IHhOP8A2hFcOcPkUBnV2c21KgqFB9Z16bYRCBXR8Of9xep/7qXTzInC/tOxaPikAIZVopYqbg5iSbETExE+W1L2pO6zqQfD7XRt+hmyniUbcwPiJzIZRxkaxFtD/eRThrPhfp9RyV4tES6fHYtadNmJF8pyjmxGgHjO36A7OSnhksNWAdjxJI4zwvEOSdST3me89AahbB0WOpKD00/Sb0p2wr9V1M57RMxqIdDW3GeW9M8RmfJPV6iXE4npL0Veo3tKdiwOqnTMOw85tKCsRNo34cphkyqBLo1dTTc03GR1tdCRcXFx6RAynMTvl6fHanbHbPB4J6T/AMDvdb+R/W0LQR0lYGllvrmB8pmn7oRdXaPs2/D039ndfNgqXYtvEaTrBPNf2RYy9B6Z3ox8m1E9Heqqi7MqjmxAHmZcebTjGYn2zhhp7ZG+5d/6AYl2rSbdnP8A6Nb/AOkDbGmTD7SpuxVXBZbZlNwy33ZlNiPETWDAcSV4wkwsCMYiUvjqSmxqoDyLqD5XjpXRtzKe4g/KBbHkbyVoHOp0Swq7kfxrVj83mqhsDDIcwopf6xUM34muYUMYQGVAOGkC7RXJiaD/AF89I9t1Lr/QfOHIK6UC1FH4piMOR/NVWmfRzALX0jSKGTgSSYttvdqKfad/FVCD0qN5TakDbar5MVTVtFqUbJyL03cuL88robcgeUAnSOkuSZ6LaTSggCukYscO3+6Vv2Mjn5qJrRZg6U1hnwtEau9bPbkiI+Zj2XZR3sISQQJASaCQAlyCAM6QgMKFIgHPULn7lIX/AK2SB9qdC8JX1KZHt76dXuuNxhbHtmxWXhTpIO5nZnb0FOb1EDy3aX7M6660aiVByfqP52IPpObxvRPHJe+Gdu1Qr/0me8iPA+aG2HimfKMNVzE2A9m49SLT3HoRsh8NhadKoeuASw5FiTlv2XtOjZY4EBWk0QRiJIQPEf2m4WomPqu62SoVem1uqy5FWwO64KkEf3nIpiDwY+B/tPpmqisLMoYcmAI8jKBgKQ3U0Hci/wBoZ2+dqVOs5si1Hv8AVVz8oawPQbH1v9P2an4qht+XUz3VKSjcAO4SaiCZ2852B0BfCsmbEOVqlkcUiKYDBCyakE2OVxpbhO4w2xMOmopqzD43u7/je5mzFfw2P1cr/hYE+l5NW0EMEBHCxGOsAb0hwYZaNUaPTqWzDeUdGDITxUkKbc1E0UDpG2ybimnNmbysB8zJUd0C4TPtdb0wMxAZ1VrGxIszZbjnl8poUTH0hfLQV/q1qX529n/zwGw2FQCwRAOWUR6uycO/v0abdpRb+dry7DbpeIAl+j6jWjWrUTyV86d2SpmAHdaR+j7QGgOFqD65arRJ70FNxftzeAhoTXSXSANEREGYzEPVqNRpOUVCBVddHLWB9mjfDYEXYa62BBBl9PZlECxpqftMMzHtLHW/beBrEF9LXAwyji2IwqqO329NvQKT4TW+EK/w3Zfsv+8T1Ob80GNs/EVayPXdMlJi6IisMz5WUO7MdbBjYDibwDNPdJmMBHIgTUzNtXZ6Yin7N7ixDo6+/Tdb5XQ8xci24gkHQy4R7wOXO0MZhurWwz1wN1XDZSGHNqTEMjdguO2N/mzEP1cPs+uXPxV8tJF7SbknuE6gRZYADY2x6gqHE4lxUxDrluoslNL3yU14C+8nU2h9RFaSgIS2nvlUnTMARRW+JxLf7igdyUkX5qYVUQPWrijiKvtLqlRldHysUN1UOpYDqsHDaHeCLcZvTHoRdA79yEerWEDUIpkbEvvFFiOQZC3lfXwMnhsWji6njYgggqRvVlOqkcjA0RWiBigIRzGjmA0RjgR7QGEUrNZb2zDw187SSODuIPcYD11vTqDdem4vyuh1lGFe6KewfKV7exIp4au19TTdF7XcZEA7SWElgUsijkB8oGxY4kRJQA/Seqafsqx/hqSlQ/UzlSjtyXMCpPDOJsw73AM2uAylWAZWBVlIBVgdCCDvBEAJsJ6RP0bEMicKVVfbU013Icyuo7CxA4QDqCBuk9cP7PCJq7OlWpb4KdNg4LcizKoA7+UsNHEkZTXROZp07N4F2YDylmB2clO+UEljd3YlndubMdSYGmiNJeJFFkoE0Erx2P8AZkL9kHzJliwJtZy1Z/s5R+RT+sCHRpf3CPxqZqrdrVWNRvVjCpjxQGMYRRQHtHiigRk4ooCiiigKKKKAooooD3jWiigSSYtq0ghXELocyJVA3OrkIjkfWViov9VjfcLKKBopNeWRRQHvHEUUCSiBsTi2rVnw6EhKYX2rg6s7C4pgjdZbE/eA5xRQCWHohAFUWA4CSqUkb3lBPPcw7mGoiigDamxEZ1d3qOFOZUd2ZFYbjlO8jgTe0JqsUUCcUUUB2jRRQGitFFAcRCKKBJTAO29h1atU1KWIamGAzKFzAsBa976dULp2RRQP/9k=)

## Adding libraries

In [1]:

    
    
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    import seaborn as sns
    from sklearn.preprocessing import StandardScaler
    from sklearn.preprocessing import OneHotEncoder
    from sklearn.preprocessing import OrdinalEncoder
    
    from sklearn.model_selection import train_test_split
    from sklearn.ensemble import GradientBoostingRegressor
    from xgboost import XGBRegressor
    from sklearn.linear_model import LinearRegression
    from sklearn.tree import DecisionTreeRegressor
    from sklearn.ensemble import RandomForestRegressor
    from sklearn import metrics
    from sklearn.metrics import r2_score
    from sklearn.model_selection import cross_val_score
    %matplotlib inline
    
    import warnings
    warnings.filterwarnings("ignore")
    

## Reading the dataset

In [2]:

    
    
    df = pd.read_csv('../input/insurance/insurance.csv')
    

## Data Overview

In [3]:

    
    
    df.head(10)
    

Out[3]:

| age | sex | bmi | children | smoker | region | charges  
---|---|---|---|---|---|---|---  
0 | 19 | female | 27.900 | 0 | yes | southwest | 16884.92400  
1 | 18 | male | 33.770 | 1 | no | southeast | 1725.55230  
2 | 28 | male | 33.000 | 3 | no | southeast | 4449.46200  
3 | 33 | male | 22.705 | 0 | no | northwest | 21984.47061  
4 | 32 | male | 28.880 | 0 | no | northwest | 3866.85520  
5 | 31 | female | 25.740 | 0 | no | southeast | 3756.62160  
6 | 46 | female | 33.440 | 1 | no | southeast | 8240.58960  
7 | 37 | female | 27.740 | 3 | no | northwest | 7281.50560  
8 | 37 | male | 29.830 | 2 | no | northeast | 6406.41070  
9 | 60 | female | 25.840 | 0 | no | northwest | 28923.13692  
  
In [4]:

    
    
    df.info()
    
    
    
    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 1338 entries, 0 to 1337
    Data columns (total 7 columns):
     #   Column    Non-Null Count  Dtype  
    ---  ------    --------------  -----  
     0   age       1338 non-null   int64  
     1   sex       1338 non-null   object 
     2   bmi       1338 non-null   float64
     3   children  1338 non-null   int64  
     4   smoker    1338 non-null   object 
     5   region    1338 non-null   object 
     6   charges   1338 non-null   float64
    dtypes: float64(2), int64(2), object(3)
    memory usage: 73.3+ KB
    

In [5]:

    
    
    df.describe()
    

Out[5]:

| age | bmi | children | charges  
---|---|---|---|---  
count | 1338.000000 | 1338.000000 | 1338.000000 | 1338.000000  
mean | 39.207025 | 30.663397 | 1.094918 | 13270.422265  
std | 14.049960 | 6.098187 | 1.205493 | 12110.011237  
min | 18.000000 | 15.960000 | 0.000000 | 1121.873900  
25% | 27.000000 | 26.296250 | 0.000000 | 4740.287150  
50% | 39.000000 | 30.400000 | 1.000000 | 9382.033000  
75% | 51.000000 | 34.693750 | 2.000000 | 16639.912515  
max | 64.000000 | 53.130000 | 5.000000 | 63770.428010  
  
In [6]:

    
    
    df.shape
    

Out[6]:

    
    
    (1338, 7)

## Checking the missing data

In [7]:

    
    
    df.isnull().sum().sort_values(ascending= False)
    

Out[7]:

    
    
    age         0
    sex         0
    bmi         0
    children    0
    smoker      0
    region      0
    charges     0
    dtype: int64

## Distribution Plot

In [8]:

    
    
    sns.displot(df['age'])
    plt.title('Age distribution')
    plt.ylabel('density')
    plt.xlabel('age')
    plt.show()
    

![](__results___files/__results___13_0.png)

In [9]:

    
    
    sns.displot(df['charges'])
    plt.title('charges distribution')
    plt.ylabel('density')
    plt.xlabel('charges')
    plt.show()
    

![](__results___files/__results___14_0.png)

In [10]:

    
    
    sns.displot(df['bmi'])
    plt.title('bmi distribution')
    plt.ylabel('density')
    plt.xlabel('bmi')
    plt.show()
    

![](__results___files/__results___15_0.png)

## Count Plot

In [11]:

    
    
    df['region'].value_counts()
    

Out[11]:

    
    
    southeast    364
    southwest    325
    northwest    325
    northeast    324
    Name: region, dtype: int64

In [12]:

    
    
    fig = plt.figure(figsize = (6,4))
    sns.countplot(df['region'])
    plt.title('region distribution')
    plt.show()
    

![](__results___files/__results___18_0.png)

In [13]:

    
    
    df['sex'].value_counts()
    

Out[13]:

    
    
    male      676
    female    662
    Name: sex, dtype: int64

In [14]:

    
    
    fig = plt.figure(figsize = (6,4))
    sns.countplot(df['sex'])
    plt.title('sex distribution')
    plt.show()
    

![](__results___files/__results___20_0.png)

In [15]:

    
    
    df['children'].value_counts()
    

Out[15]:

    
    
    0    574
    1    324
    2    240
    3    157
    4     25
    5     18
    Name: children, dtype: int64

In [16]:

    
    
    fig = plt.figure(figsize = (6,4))
    sns.countplot(df['children'])
    plt.title('children distribution')
    plt.show()
    

![](__results___files/__results___22_0.png)

## Checking the correlation

In [17]:

    
    
    df['sex'] = pd.factorize(df['sex'])[0] + 1
    df['region'] = pd.factorize(df['region'])[0] + 1
    df['smoker'] = pd.factorize(df['smoker'])[0] + 1
    corr = df.corr()
    corr['charges'].sort_values(ascending=False)
    

Out[17]:

    
    
    charges     1.000000
    age         0.299008
    bmi         0.198341
    children    0.067998
    sex         0.057292
    region      0.006208
    smoker     -0.787251
    Name: charges, dtype: float64

## Correlation Plot

In [18]:

    
    
    fig = plt.figure(figsize = (6, 4))
    data_ploting = df.corr(method= 'pearson')
    sns.heatmap(data_ploting, cmap='Reds', linecolor='black', linewidths= 2 )
    plt.show()
    

![](__results___files/__results___26_0.png)

## Pair Plot

In [19]:

    
    
    fig = plt.figure(figsize = (6, 4))
    sns.pairplot(df,diag_kind='kde');
    
    
    
    <Figure size 432x288 with 0 Axes>

![](__results___files/__results___28_1.png)

## Train and Test Split

In [20]:

    
    
    X = df.drop('charges', axis = 1)
    y = df['charges']
    X_train, X_test, y_train, y_test= train_test_split(X, y, test_size=0.3, random_state=101)
    

## Scalling data

In [21]:

    
    
    scaler= StandardScaler()
    scaler.fit(X_train)
    X_train_scaled= scaler.transform(X_train)
    X_test_scaled= scaler.transform(X_test)
    

## Linear Regression Model

In [22]:

    
    
    linear_reg_model= LinearRegression()
    linear_reg_model.fit(X_train_scaled, y_train)
    

Out[22]:

    
    
    LinearRegression()

In [23]:

    
    
    y_pred = linear_reg_model.predict(X_test_scaled)
    y_pred = pd.DataFrame(y_pred)
    MAE_li_reg= metrics.mean_absolute_error(y_test, y_pred)
    MSE_li_reg = metrics.mean_squared_error(y_test, y_pred)
    RMSE_li_reg =np.sqrt(MSE_li_reg)
    pd.DataFrame([MAE_li_reg, MSE_li_reg, RMSE_li_reg], index=['MAE_li_reg', 'MSE_li_reg', 'RMSE_li_reg'], columns=['Metrics'])
    

Out[23]:

| Metrics  
---|---  
MAE_li_reg | 3.990250e+03  
MSE_li_reg | 3.353013e+07  
RMSE_li_reg | 5.790521e+03  
  
In [24]:

    
    
    scores = cross_val_score(linear_reg_model, X_train_scaled, y_train, cv=5)
    print(np.sqrt(scores))
    
    
    
    [0.88791389 0.85653048 0.84404195 0.87198372 0.84417492]
    

In [25]:

    
    
    r2_score(y_test, linear_reg_model.predict(X_test_scaled))
    

Out[25]:

    
    
    0.7613126015198817

## Gradient Boosting Regressor Model

In [26]:

    
    
    Gradient_model = GradientBoostingRegressor()
    Gradient_model.fit(X_train_scaled, y_train)
    

Out[26]:

    
    
    GradientBoostingRegressor()

In [27]:

    
    
    y_pred = Gradient_model.predict(X_test_scaled)
    y_pred = pd.DataFrame(y_pred)
    MAE_gradient= metrics.mean_absolute_error(y_test, y_pred)
    MSE_gradient = metrics.mean_squared_error(y_test, y_pred)
    RMSE_gradient =np.sqrt(MSE_gradient)
    pd.DataFrame([MAE_gradient, MSE_gradient, RMSE_gradient], index=['MAE_gradient', 'MSE_gradient', 'RMSE_gradient'], columns=['Metrics'])
    

Out[27]:

| Metrics  
---|---  
MAE_gradient | 2.528851e+03  
MSE_gradient | 2.110725e+07  
RMSE_gradient | 4.594262e+03  
  
In [28]:

    
    
    scores = cross_val_score(Gradient_model, X_train_scaled, y_train, cv=5)
    print(np.sqrt(scores))
    
    
    
    [0.94585345 0.91432953 0.91680589 0.9228401  0.91717029]
    

In [29]:

    
    
    r2_score(y_test, Gradient_model.predict(X_test_scaled))
    

Out[29]:

    
    
    0.849746079970233

## XGB Regressor Model

In [30]:

    
    
    XGB_model =XGBRegressor()
    XGB_model.fit(X_train_scaled, y_train);
    

In [31]:

    
    
    y_pred = XGB_model.predict(X_test_scaled)
    y_pred = pd.DataFrame(y_pred)
    MAE_XGB= metrics.mean_absolute_error(y_test, y_pred)
    MSE_XGB = metrics.mean_squared_error(y_test, y_pred)
    RMSE_XGB =np.sqrt(MSE_XGB)
    pd.DataFrame([MAE_XGB, MSE_XGB, RMSE_XGB], index=['MAE_XGB', 'MSE_XGB', 'RMSE_XGB'], columns=['Metrics'])
    

Out[31]:

| Metrics  
---|---  
MAE_XGB | 3.103218e+03  
MSE_XGB | 2.913335e+07  
RMSE_XGB | 5.397532e+03  
  
In [32]:

    
    
    scores = cross_val_score(XGB_model, X_train_scaled, y_train, cv=5)
    print(np.sqrt(scores))
    
    
    
    [0.93063684 0.88131858 0.90244945 0.89712902 0.88179435]
    

In [33]:

    
    
    r2_score(y_test, XGB_model.predict(X_test_scaled))
    

Out[33]:

    
    
    0.792611508214176

## Decision Tree Regressor Model

In [34]:

    
    
    tree_reg_model =DecisionTreeRegressor()
    tree_reg_model.fit(X_train_scaled, y_train);
    

In [35]:

    
    
    y_pred = tree_reg_model.predict(X_test_scaled)
    y_pred = pd.DataFrame(y_pred)
    MAE_tree_reg= metrics.mean_absolute_error(y_test, y_pred)
    MSE_tree_reg = metrics.mean_squared_error(y_test, y_pred)
    RMSE_tree_reg =np.sqrt(MSE_tree_reg)
    pd.DataFrame([MAE_tree_reg, MSE_tree_reg, RMSE_tree_reg], index=['MAE_tree_reg', 'MSE_tree_reg', 'RMSE_tree_reg'], columns=['Metrics'])
    

Out[35]:

| Metrics  
---|---  
MAE_tree_reg | 3.440970e+03  
MSE_tree_reg | 4.894771e+07  
RMSE_tree_reg | 6.996264e+03  
  
In [36]:

    
    
    scores = cross_val_score(tree_reg_model, X_train_scaled, y_train, cv=5)
    print(np.sqrt(scores))
    
    
    
    [0.84578307 0.80172547 0.85196812 0.85885143 0.85433138]
    

In [37]:

    
    
    r2_score(y_test, tree_reg_model.predict(X_test_scaled))
    

Out[37]:

    
    
    0.6515611190560285

## Random Forest Regressor Model

In [38]:

    
    
    forest_reg_model =RandomForestRegressor()
    forest_reg_model.fit(X_train_scaled, y_train);
    

In [39]:

    
    
    y_pred = forest_reg_model.predict(X_test_scaled)
    y_pred = pd.DataFrame(y_pred)
    MAE_forest_reg= metrics.mean_absolute_error(y_test, y_pred)
    MSE_forest_reg = metrics.mean_squared_error(y_test, y_pred)
    RMSE_forest_reg =np.sqrt(MSE_forest_reg)
    pd.DataFrame([MAE_forest_reg, MSE_forest_reg, RMSE_forest_reg], index=['MAE_forest_reg', 'MSE_forest_reg', 'RMSE_forest_reg'], columns=['Metrics'])
    

Out[39]:

| Metrics  
---|---  
MAE_forest_reg | 2.855739e+03  
MSE_forest_reg | 2.493603e+07  
RMSE_forest_reg | 4.993598e+03  
  
In [40]:

    
    
    scores = cross_val_score(forest_reg_model, X_train_scaled, y_train, cv=5)
    print(np.sqrt(scores))
    
    
    
    [0.94226885 0.90341162 0.92159518 0.91315664 0.90381767]
    

In [41]:

    
    
    r2_score(y_test, forest_reg_model.predict(X_test_scaled))
    

Out[41]:

    
    
    0.8224905506383428

